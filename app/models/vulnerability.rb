# frozen_string_literal: true

class Vulnerability < ActiveRecord::Base
  enum severity: { low: 0, medium: 1, high: 2 }

  has_many :releases_vulnerabilities
  has_many :releases, through: :releases_vulnerabilities, counter_cache: true

  scope :sort_by, ->(col = 'cve_id', order = :desc) { order("#{col}": order) }
  scope :unknown_severity, -> { where('severity is null') }

  DESC_LENGTH = 150

  class << self
    def severity_exists?(name)
      severities.key?(name)
    end

    def details(release_id, filter: {}, sort: {})
      severity = Vulnerability.severities[filter[:severity]]
      condition = sanitize_sql " AND V.severity=#{severity}" if severity
      condition ||= ' AND V.severity is null' if filter[:severity]
      order = sanitize_sql "V.#{sort[:col]} #{sort[:direction]}" if sort[:col]

      find_by_sql(["SELECT V.id, V.cve_id, V.severity, V.published_on, V.description,
          ARRAY_TO_STRING((ARRAY_AGG(R.version ORDER BY R.released_on DESC))[1:10], ', ') AS recent_releases
        FROM vulnerabilities AS V INNER JOIN releases_vulnerabilities AS RV
          ON RV.vulnerability_id = V.id INNER JOIN releases AS R ON R.id=RV.release_id
        WHERE V.id IN (#{sanitize_sql(release_vulnerability_ids(release_id).join(','))}) #{condition}
        GROUP BY V.id ORDER BY #{order || 'V.cve_id DESC'}"])
    end

    private

    def release_vulnerability_ids(release_id)
      query = sanitize_sql("SELECT RVT.vulnerability_id FROM releases_vulnerabilities RVT
                            WHERE RVT.release_id= #{release_id}")
      vulnerability_ids = connection.execute(query).values.flatten
      return ['null'] if vulnerability_ids.blank?

      vulnerability_ids.map(&:to_i)
    end
  end

  def years_ago?(year = 1)
    published_on.to_date <= year.to_i.years.ago.to_date
  end
end
